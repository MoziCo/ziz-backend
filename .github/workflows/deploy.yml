name: Deploy Ziz API

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  REGISTRY: docker.io
  API_IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/ziz-api
  API_SERVICE_ID: ${{ secrets.API_SERVICE_ID }}
  RAILWAY_ENVIRONMENT_ID: ${{ secrets.RAILWAY_ENVIRONMENT_ID }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      api: ${{ steps.changes.outputs.api }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          api:
            - 'ziz/**'
            - 'tests/**'
            - 'pyproject.toml'
            - 'poetry.lock'
            - 'Dockerfile'
            - '.github/workflows/deploy.yml'

  build-api:
    needs: detect-changes
    if: needs.detect-changes.outputs.api == 'true'
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Generate short SHA and tags
      id: meta
      run: |
        SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-6)
        echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "üè∑Ô∏è Short SHA: ${SHORT_SHA}"
        echo "üåø Branch: ${{ github.ref }}"

        # Generate tags
        TAGS="${{ env.API_IMAGE_NAME }}:${SHORT_SHA}"
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          TAGS="${TAGS},${{ env.API_IMAGE_NAME }}:latest"
          echo "‚úÖ Adding latest tag for main branch"
        else
          echo "‚ÑπÔ∏è Skipping latest tag for feature branch"
        fi
        echo "üè∑Ô∏è Tags: ${TAGS}"
        echo "tags=${TAGS}" >> $GITHUB_OUTPUT

    - name: Build and push API image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        target: api

  deploy-api:
    needs: [detect-changes, build-api]
    if: needs.detect-changes.outputs.api == 'true' && needs.build-api.result == 'success'
    runs-on: ubuntu-latest

    steps:
    - name: Update API Docker image on Railway
      env:
        RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}
      run: |
        SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-6)
        echo "üöÄ Deploying API image: ${{ env.API_IMAGE_NAME }}:${SHORT_SHA}"
        echo "üìã Service ID: ${{ env.API_SERVICE_ID }}"

        # Update service source to new Docker image
        echo "üìù Updating service Docker image source..."
        UPDATE_RESPONSE=$(curl -s -X POST https://backboard.railway.com/graphql/v2 \
          -H "Authorization: Bearer $RAILWAY_TOKEN" \
          -H "Content-Type: application/json" \
          -d "{\"query\": \"mutation serviceInstanceUpdate(\$environmentId: String, \$serviceId: String!, \$input: ServiceInstanceUpdateInput!) { serviceInstanceUpdate(environmentId: \$environmentId, serviceId: \$serviceId, input: \$input) }\", \"variables\": {\"environmentId\": \"${{ env.RAILWAY_ENVIRONMENT_ID }}\", \"serviceId\": \"${{ env.API_SERVICE_ID }}\", \"input\": {\"source\": {\"image\": \"${{ env.API_IMAGE_NAME }}:${SHORT_SHA}\"}}}}")

        echo "üìÑ Update Response:"
        echo "$UPDATE_RESPONSE" | jq '.' || echo "$UPDATE_RESPONSE"

        # Check for errors in update response
        if echo "$UPDATE_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
          echo "‚ùå Error updating service image:"
          echo "$UPDATE_RESPONSE" | jq '.errors'
          exit 1
        fi

        # Check if update was successful (should return true)
        UPDATE_SUCCESS=$(echo "$UPDATE_RESPONSE" | jq -r '.data.serviceInstanceUpdate')
        if [[ "$UPDATE_SUCCESS" != "true" ]]; then
          echo "‚ùå API service update failed or returned unexpected response"
          echo "Expected: true, Got: $UPDATE_SUCCESS"
          exit 1
        fi
        echo "‚úÖ API service image updated successfully"

        # Trigger redeploy
        echo "üîÑ Triggering service redeploy..."
        DEPLOY_RESPONSE=$(curl -s -X POST https://backboard.railway.com/graphql/v2 \
          -H "Authorization: Bearer $RAILWAY_TOKEN" \
          -H "Content-Type: application/json" \
          -d "{\"query\": \"mutation serviceInstanceDeployV2(\$environmentId: String!, \$serviceId: String!) { serviceInstanceDeployV2(environmentId: \$environmentId, serviceId: \$serviceId) }\", \"variables\": {\"environmentId\": \"${{ env.RAILWAY_ENVIRONMENT_ID }}\", \"serviceId\": \"${{ env.API_SERVICE_ID }}\"}}")

        echo "üìÑ Deploy Response:"
        echo "$DEPLOY_RESPONSE" | jq '.' || echo "$DEPLOY_RESPONSE"

        # Check for errors in deploy response
        if echo "$DEPLOY_RESPONSE" | jq -e '.errors' > /dev/null 2>&1; then
          echo "‚ùå Error triggering deployment:"
          echo "$DEPLOY_RESPONSE" | jq '.errors'
          exit 1
        fi

        # Check if redeploy was successful (should return deployment ID)
        DEPLOY_ID=$(echo "$DEPLOY_RESPONSE" | jq -r '.data.serviceInstanceDeployV2')
        if [[ "$DEPLOY_ID" == "null" || -z "$DEPLOY_ID" ]]; then
          echo "‚ùå API service redeploy failed or returned unexpected response"
          echo "Expected: deployment ID, Got: $DEPLOY_ID"
          exit 1
        fi
        echo "üìã Deployment ID: $DEPLOY_ID"
        echo "‚úÖ API service redeploy triggered successfully"

  notify-deployment:
    needs: [detect-changes, deploy-api]
    if: always()
    runs-on: ubuntu-latest

    steps:
    - name: Notify deployment results
      run: |
        if [[ "${{ needs.deploy-api.result }}" == "success" ]]; then
          echo "üöÄ Deployment completed!"
          echo "‚úÖ Ziz API deployed successfully: ${{ secrets.API_URL }}"
        elif [[ "${{ needs.detect-changes.outputs.api }}" == "false" ]]; then
          echo "‚è≠Ô∏è No changes detected - skipping deployment"
        else
          echo "‚ùå Deployment failed! Check the logs above for details."
          exit 1
        fi
